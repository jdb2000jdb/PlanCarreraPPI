<!doctype html>
<html>
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta http-equiv="X-UA-Compatible" content="ie=edge" />
<title>Markmap</title>
<style>
* {
  margin: 0;
  padding: 0;
}
html {
  font-family: ui-sans-serif, system-ui, sans-serif, 'Apple Color Emoji',
    'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
.markmap-dark {
  background: #27272a;
  color: white;
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.18.12/dist/style.css">
</head>
<body>
<svg id="mindmap"></svg>
<script src="https://cdn.jsdelivr.net/npm/d3@7.9.0/dist/d3.min.js"></script><script src="https://cdn.jsdelivr.net/npm/markmap-view@0.18.12/dist/browser/index.js"></script><script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.18.12/dist/index.js"></script><script>(()=>{setTimeout(()=>{const{markmap:S,mm:Q}=window,$=new S.Toolbar;$.attach(Q);const I=$.render();I.setAttribute("style","position:absolute;bottom:20px;right:20px"),document.body.append(I)})})()</script><script>((l,U,M,R)=>{const N=l();window.mm=N.Markmap.create("svg#mindmap",(U||N.deriveOptions)(R),M),window.matchMedia("(prefers-color-scheme: dark)").matches&&document.documentElement.classList.add("markmap-dark")})(()=>window.markmap,null,{"content":"Ingenier&#xed;a en Inform&#xe1;tica 2026","children":[{"content":"1er A&#xf1;o","children":[{"content":"PPI","children":[{"content":"\n<p data-lines=\"17,18\">bjetivos</p>","children":[{"content":"Optimizar el dise&#xf1;o y la calidad del c&#xf3;digo imperativo.<br>\nContenidos M&#xed;nimos Paradigmas y lenguajes de programaci&#xf3;n. Algoritmos. Estructura de control: secuencial, selectivas y repetitivas. Modularizaci&#xf3;n. Estructuras de datos est&#xe1;ticas. Algoritmos de b&#xfa;squeda y ordenamiento. Punteros. Estructuras de datos din&#xe1;micas. Tipo de datos abstractos (Lista, Cola, Pila). Recursividad. Archivos.","children":[],"payload":{"tag":"li","lines":"18,22"}}],"payload":{"tag":"li","lines":"17,22"}},{"content":"\n<p data-lines=\"22,23\"><mark>Propuesta Estrat&#xe9;gica PPI &amp; IA</mark></p>","children":[{"content":"<a href=\"https://docs.google.com/document/d/1kuhi3sgQXMqNv_Y0TTdbfXUL5XXXTgp_MOGzI317wVw/edit?usp=sharing\">Lineamientos Estrat&#xe9;gicos en formato Doc</a>","children":[],"payload":{"tag":"li","lines":"23,24"}},{"content":"<a href=\"https://gemini.google.com/share/ca1fb8bbfd35\">Lineamientos Estrat&#xe9;gicos en formato Web</a>","children":[],"payload":{"tag":"li","lines":"24,25"}},{"content":"Prototipo 1","children":[{"content":"<a href=\"https://gemini.google.com/gem/16QVi3kwTYcIwKDzukT0j3uMDIQhF03b7?usp=sharing\">Prototipo 1: Asistente de consignas de Lenguaje C</a>","children":[],"payload":{"tag":"li","lines":"26,27"}},{"content":"<a href=\"https://docs.google.com/document/d/1Yd3V0h98Fh-vVEA8VWsHBbIfxoFcP7A80avjgEgkFUU/edit?usp=sharing\">Clasificaci&#xf3;n Pedag&#xf3;gica y Metodolog&#xed;as</a>","children":[],"payload":{"tag":"li","lines":"27,32"}}],"payload":{"tag":"li","lines":"25,32"}}],"payload":{"tag":"li","lines":"22,32"}},{"content":"\n<p data-lines=\"32,33\">Bibliograf&#xed;a</p>","children":[{"content":"<a href=\"https://drive.google.com/file/d/1q_xR04sN26UvdsMuKtml-pvx7Y1bB3WC/view?usp=sharing\">C&#xf3;mo Programar en C y C++, 2da Ed. Deitel &amp; Deitel</a>","children":[{"content":"\n<p data-lines=\"34,35\">Cap&#xed;tulo 1 - Conceptos de computaci&#xf3;n - P&#xe1;gina 1</p>","children":[{"content":"1.1 Introducci&#xf3;n - P&#xe1;gina 2","children":[],"payload":{"tag":"li","lines":"35,36"}},{"content":"1.2 &#xbf;Qu&#xe9; es una computadora? - P&#xe1;gina 4","children":[],"payload":{"tag":"li","lines":"36,37"}},{"content":"1.3 Organizaci&#xf3;n de la computadora - P&#xe1;gina 4","children":[],"payload":{"tag":"li","lines":"37,38"}},{"content":"1.4 Procesamiento por lotes, programaci&#xf3;n m&#xfa;ltiple y tiempo compartido - P&#xe1;gina 5","children":[],"payload":{"tag":"li","lines":"38,39"}},{"content":"1.5 Computaci&#xf3;n personal, computaci&#xf3;n distribuida y computaci&#xf3;n cliente/servidor - P&#xe1;gina 6","children":[],"payload":{"tag":"li","lines":"39,40"}},{"content":"1.6 Lenguajes m&#xe1;quina, lenguajes ensambladores y lenguajes de alto nivel - P&#xe1;gina 6","children":[],"payload":{"tag":"li","lines":"40,41"}},{"content":"1.7 La historia de C - P&#xe1;gina 7","children":[],"payload":{"tag":"li","lines":"41,42"}},{"content":"1.8 La biblioteca est&#xe1;ndar de C - P&#xe1;gina 8","children":[],"payload":{"tag":"li","lines":"42,43"}},{"content":"1.9 Otros lenguajes de alto nivel - P&#xe1;gina 9","children":[],"payload":{"tag":"li","lines":"43,44"}},{"content":"1.10 Programaci&#xf3;n estructurada - P&#xe1;gina 9","children":[],"payload":{"tag":"li","lines":"44,45"}},{"content":"1.11 Los fundamentos del entorno de C - P&#xe1;gina 10","children":[],"payload":{"tag":"li","lines":"45,46"}},{"content":"1.12 Notas generales sobre C y este libro - P&#xe1;gina 10","children":[],"payload":{"tag":"li","lines":"46,47"}},{"content":"1.13 C concurrente - P&#xe1;gina 12","children":[],"payload":{"tag":"li","lines":"47,48"}},{"content":"1.14 Programaci&#xf3;n orientada a objetos y C++ - P&#xe1;gina 14","children":[],"payload":{"tag":"li","lines":"48,50"}}],"payload":{"tag":"li","lines":"34,50"}},{"content":"\n<p data-lines=\"50,51\">Cap&#xed;tulo 2 - Introducci&#xf3;n a la programaci&#xf3;n en C - P&#xe1;gina 23</p>","children":[{"content":"2.1 Introducci&#xf3;n - P&#xe1;gina 24","children":[],"payload":{"tag":"li","lines":"51,52"}},{"content":"2.2 Un programa simple en C: imprimir una l&#xed;nea de texto - P&#xe1;gina 24","children":[],"payload":{"tag":"li","lines":"52,53"}},{"content":"2.3 Otro programa simple en C: sumar dos enteros - P&#xe1;gina 28","children":[],"payload":{"tag":"li","lines":"53,54"}},{"content":"2.4 Conceptos de memoria - P&#xe1;gina 33","children":[],"payload":{"tag":"li","lines":"54,55"}},{"content":"2.5 Aritm&#xe9;tica en C - P&#xe1;gina 34","children":[],"payload":{"tag":"li","lines":"55,56"}},{"content":"2.6 Toma de decisiones: operadores de igualdad y relacionales - P&#xe1;gina 37","children":[],"payload":{"tag":"li","lines":"56,58"}}],"payload":{"tag":"li","lines":"50,58"}},{"content":"\n<p data-lines=\"58,59\">Cap&#xed;tulo 3 - Desarrollo de programas estructurados - P&#xe1;gina 55</p>","children":[{"content":"3.1 Introducci&#xf3;n - P&#xe1;gina 56","children":[],"payload":{"tag":"li","lines":"59,60"}},{"content":"3.2 Algoritmos - P&#xe1;gina 56","children":[],"payload":{"tag":"li","lines":"60,61"}},{"content":"3.3 Pseudoc&#xf3;digo - P&#xe1;gina 57","children":[],"payload":{"tag":"li","lines":"61,62"}},{"content":"3.4 Estructuras de control - P&#xe1;gina 58","children":[],"payload":{"tag":"li","lines":"62,63"}},{"content":"3.5 La estructura de selecci&#xf3;n If - P&#xe1;gina 60","children":[],"payload":{"tag":"li","lines":"63,64"}},{"content":"3.6 La estructura de selecci&#xf3;n If/Else - P&#xe1;gina 61","children":[],"payload":{"tag":"li","lines":"64,65"}},{"content":"3.7 La estructura de repetici&#xf3;n While - P&#xe1;gina 65","children":[],"payload":{"tag":"li","lines":"65,66"}},{"content":"3.8 C&#xf3;mo formular algoritmos: Estudio de caso 1 (repetici&#xf3;n controlada por contador) - P&#xe1;gina 67","children":[],"payload":{"tag":"li","lines":"66,67"}},{"content":"3.9 C&#xf3;mo formular algoritmos con refinamiento descendente paso a paso: Estudio de caso 2 (repetici&#xf3;n controlada por centinela) - P&#xe1;gina 69","children":[],"payload":{"tag":"li","lines":"67,68"}},{"content":"3.10 C&#xf3;mo formular algoritmos con refinamiento descendente paso a paso: Estudio de caso 3 (estructuras de control anidadas) - P&#xe1;gina 74","children":[],"payload":{"tag":"li","lines":"68,69"}},{"content":"3.11 Operadores de asignaci&#xf3;n - P&#xe1;gina 77","children":[],"payload":{"tag":"li","lines":"69,70"}},{"content":"3.12 Operadores incrementales y decrementales - P&#xe1;gina 79","children":[],"payload":{"tag":"li","lines":"70,72"}}],"payload":{"tag":"li","lines":"58,72"}},{"content":"\n<p data-lines=\"72,73\">Cap&#xed;tulo 4 - Control de programa - P&#xe1;gina 101</p>","children":[{"content":"4.1 Introducci&#xf3;n - P&#xe1;gina 102","children":[],"payload":{"tag":"li","lines":"73,74"}},{"content":"4.2 Lo esencial de la repetici&#xf3;n - P&#xe1;gina 102","children":[],"payload":{"tag":"li","lines":"74,75"}},{"content":"4.3 Repetici&#xf3;n controlada por contador - P&#xe1;gina 103","children":[],"payload":{"tag":"li","lines":"75,76"}},{"content":"4.4 La estructura de repetici&#xf3;n for - P&#xe1;gina 105","children":[],"payload":{"tag":"li","lines":"76,77"}},{"content":"4.5 La estructura for: Notas y observaciones - P&#xe1;gina 108","children":[],"payload":{"tag":"li","lines":"77,78"}},{"content":"4.6 Ejemplos utilizando la estructura for - P&#xe1;gina 108","children":[],"payload":{"tag":"li","lines":"78,79"}},{"content":"4.7 La estructura de selecci&#xf3;n m&#xfa;ltiple Switch - P&#xe1;gina 112","children":[],"payload":{"tag":"li","lines":"79,80"}},{"content":"4.8 La estructura de repetici&#xf3;n do/while - P&#xe1;gina 118","children":[],"payload":{"tag":"li","lines":"80,81"}},{"content":"4.9 Los enunciados break y continue - P&#xe1;gina 120","children":[],"payload":{"tag":"li","lines":"81,82"}},{"content":"4.10 Operadores l&#xf3;gicos - P&#xe1;gina 122","children":[],"payload":{"tag":"li","lines":"82,83"}},{"content":"4.11 Confusi&#xf3;n entre los operadores de igualdad (==) y de asignaci&#xf3;n (=) - P&#xe1;gina 124","children":[],"payload":{"tag":"li","lines":"83,84"}},{"content":"4.12 Resumen de programaci&#xf3;n estructurada - P&#xe1;gina 126","children":[],"payload":{"tag":"li","lines":"84,86"}}],"payload":{"tag":"li","lines":"72,86"}},{"content":"\n<p data-lines=\"86,87\">Cap&#xed;tulo 5 - Funciones - P&#xe1;gina 147**</p>","children":[{"content":"5.1 Introducci&#xf3;n - P&#xe1;gina 148","children":[],"payload":{"tag":"li","lines":"87,88"}},{"content":"5.2 M&#xf3;dulos de programa en C - P&#xe1;gina 148","children":[],"payload":{"tag":"li","lines":"88,89"}},{"content":"5.3 Funciones matem&#xe1;ticas de biblioteca - P&#xe1;gina 149","children":[],"payload":{"tag":"li","lines":"89,90"}},{"content":"5.4 Funciones - P&#xe1;gina 150","children":[],"payload":{"tag":"li","lines":"90,91"}},{"content":"5.5 Definiciones de funci&#xf3;n - P&#xe1;gina 152","children":[],"payload":{"tag":"li","lines":"91,92"}},{"content":"5.6 Prototipo de funciones - P&#xe1;gina 155","children":[],"payload":{"tag":"li","lines":"92,93"}},{"content":"5.7 Archivos de cabecera - P&#xe1;gina 159","children":[],"payload":{"tag":"li","lines":"93,94"}},{"content":"5.8 C&#xf3;mo llamar funciones: llamada por valor y llamada por referencia - P&#xe1;gina 160","children":[],"payload":{"tag":"li","lines":"94,95"}},{"content":"5.9 Generaci&#xf3;n de n&#xfa;meros aleatorios - P&#xe1;gina 160","children":[],"payload":{"tag":"li","lines":"95,96"}},{"content":"5.10 Ejemplo: un juego de azar - P&#xe1;gina 165","children":[],"payload":{"tag":"li","lines":"96,97"}},{"content":"5.11 Clases de almacenamiento - P&#xe1;gina 168","children":[],"payload":{"tag":"li","lines":"97,98"}},{"content":"5.12 Reglas de alcance - P&#xe1;gina 170","children":[],"payload":{"tag":"li","lines":"98,99"}},{"content":"5.13 Recursi&#xf3;n - P&#xe1;gina 171","children":[],"payload":{"tag":"li","lines":"99,100"}},{"content":"5.14 Ejemplo utilizando recursi&#xf3;n: la serie Fibonacci - P&#xe1;gina 176","children":[],"payload":{"tag":"li","lines":"100,101"}},{"content":"5.15 Recursi&#xf3;n en comparaci&#xf3;n con iteraci&#xf3;n - P&#xe1;gina 180","children":[],"payload":{"tag":"li","lines":"101,103"}}],"payload":{"tag":"li","lines":"86,103"}},{"content":"\n<p data-lines=\"103,104\">Cap&#xed;tulo 6 - Arreglos - P&#xe1;gina 203</p>","children":[{"content":"6.1 Introducci&#xf3;n - P&#xe1;gina 204","children":[],"payload":{"tag":"li","lines":"104,105"}},{"content":"6.2 Arreglos - P&#xe1;gina 204","children":[],"payload":{"tag":"li","lines":"105,106"}},{"content":"6.3 C&#xf3;mo declarar arreglos - P&#xe1;gina 206","children":[],"payload":{"tag":"li","lines":"106,107"}},{"content":"6.4 Ejemplos utilizando arreglos - P&#xe1;gina 207","children":[],"payload":{"tag":"li","lines":"107,108"}},{"content":"6.5 C&#xf3;mo pasar arreglos a funciones - P&#xe1;gina 217","children":[],"payload":{"tag":"li","lines":"108,109"}},{"content":"6.6 C&#xf3;mo ordenar arreglos - P&#xe1;gina 223","children":[],"payload":{"tag":"li","lines":"109,110"}},{"content":"6.7 Estudio de caso: C&#xf3;mo calcular el promedio, la mediana y el modo utilizando arreglos - P&#xe1;gina 225","children":[],"payload":{"tag":"li","lines":"110,111"}},{"content":"6.8 B&#xfa;squeda en arreglos - P&#xe1;gina 228","children":[],"payload":{"tag":"li","lines":"111,112"}},{"content":"6.9 Arreglos con m&#xfa;ltiples sub&#xed;ndices - P&#xe1;gina 231","children":[],"payload":{"tag":"li","lines":"112,114"}}],"payload":{"tag":"li","lines":"103,114"}},{"content":"\n<p data-lines=\"114,115\">Cap&#xed;tulo 7 - Punteros - P&#xe1;gina 259</p>","children":[{"content":"7.1 Introducci&#xf3;n - P&#xe1;gina 260","children":[],"payload":{"tag":"li","lines":"115,116"}},{"content":"7.2 Declaraciones e inicializaci&#xf3;n de variables de apuntadores - P&#xe1;gina 260","children":[],"payload":{"tag":"li","lines":"116,117"}},{"content":"7.3 Operadores de apuntador - P&#xe1;gina 261","children":[],"payload":{"tag":"li","lines":"117,118"}},{"content":"7.4 C&#xf3;mo llamar funciones por referencia - P&#xe1;gina 263","children":[],"payload":{"tag":"li","lines":"118,119"}},{"content":"7.5 C&#xf3;mo usar el calificador const con apuntadores - P&#xe1;gina 268","children":[],"payload":{"tag":"li","lines":"119,120"}},{"content":"7.6 Ordenamiento de tipo burbuja utilizando llamadas por referencia - P&#xe1;gina 272","children":[],"payload":{"tag":"li","lines":"120,121"}},{"content":"7.7 Expresiones de punteros y aritm&#xe9;tica de apuntadores - P&#xe1;gina 277","children":[],"payload":{"tag":"li","lines":"121,122"}},{"content":"7.8 Relaci&#xf3;n entre apuntadores y arreglos - P&#xe1;gina 281","children":[],"payload":{"tag":"li","lines":"122,123"}},{"content":"7.9 Arreglos de apuntadores - P&#xe1;gina 284","children":[],"payload":{"tag":"li","lines":"123,124"}},{"content":"7.10 Estudio de caso: simulaci&#xf3;n de barajar y repartir cartas - P&#xe1;gina 286","children":[],"payload":{"tag":"li","lines":"124,125"}},{"content":"7.11 Apuntadores a funciones - P&#xe1;gina 291","children":[],"payload":{"tag":"li","lines":"125,127"}}],"payload":{"tag":"li","lines":"114,127"}},{"content":"\n<p data-lines=\"127,128\">Cap&#xed;tulo 8 - Caracteres y cadenas - P&#xe1;gina 317</p>","children":[{"content":"8.1 Introducci&#xf3;n - P&#xe1;gina 318","children":[],"payload":{"tag":"li","lines":"128,129"}},{"content":"8.2 Fundamentos de cadenas y caracteres - P&#xe1;gina 318","children":[],"payload":{"tag":"li","lines":"129,130"}},{"content":"8.3 Biblioteca de manejo de caracteres - P&#xe1;gina 320","children":[],"payload":{"tag":"li","lines":"130,131"}},{"content":"8.4 Funciones de conversi&#xf3;n de cadenas - P&#xe1;gina 325","children":[],"payload":{"tag":"li","lines":"131,132"}},{"content":"8.5 Funciones de la biblioteca est&#xe1;ndar de entradas/salidas - P&#xe1;gina 330","children":[],"payload":{"tag":"li","lines":"132,133"}},{"content":"8.6 Funciones de manipulaci&#xf3;n de cadenas de la biblioteca de manejo de cadenas - P&#xe1;gina 333","children":[],"payload":{"tag":"li","lines":"133,134"}},{"content":"8.7 Funciones de comparaci&#xf3;n de la biblioteca de manejo de cadenas - P&#xe1;gina 336","children":[],"payload":{"tag":"li","lines":"134,135"}},{"content":"8.8 Funciones de b&#xfa;squeda de la biblioteca de manejo de cadenas - P&#xe1;gina 338","children":[],"payload":{"tag":"li","lines":"135,136"}},{"content":"8.9 Funciones de memoria de la biblioteca de manejo de cadenas - P&#xe1;gina 344","children":[],"payload":{"tag":"li","lines":"136,137"}},{"content":"8.10 Otras funciones de la biblioteca de manejo de cadenas - P&#xe1;gina 347","children":[],"payload":{"tag":"li","lines":"137,139"}}],"payload":{"tag":"li","lines":"127,139"}},{"content":"\n<p data-lines=\"139,140\">Cap&#xed;tulo 9 - Entrada/Salida con formato - P&#xe1;gina 365</p>","children":[{"content":"9.1 Introducci&#xf3;n - P&#xe1;gina 366","children":[],"payload":{"tag":"li","lines":"140,141"}},{"content":"9.2 Flujos - P&#xe1;gina 366","children":[],"payload":{"tag":"li","lines":"141,142"}},{"content":"9.3 Salida con formato mediante printf - P&#xe1;gina 367","children":[],"payload":{"tag":"li","lines":"142,143"}},{"content":"9.4 C&#xf3;mo imprimir enteros - P&#xe1;gina 367","children":[],"payload":{"tag":"li","lines":"143,144"}},{"content":"9.5 C&#xf3;mo imprimir n&#xfa;meros de punto flotante - P&#xe1;gina 369","children":[],"payload":{"tag":"li","lines":"144,145"}},{"content":"9.6 C&#xf3;mo imprimir cadenas y caracteres - P&#xe1;gina 371","children":[],"payload":{"tag":"li","lines":"145,146"}},{"content":"9.7 Otros especificadores de conversi&#xf3;n - P&#xe1;gina 372","children":[],"payload":{"tag":"li","lines":"146,147"}},{"content":"9.8 C&#xf3;mo imprimir con anchos de campo y precisiones - P&#xe1;gina 372","children":[],"payload":{"tag":"li","lines":"147,148"}},{"content":"9.9 Uso de banderas en la cadena de control de formato printf - P&#xe1;gina 375","children":[],"payload":{"tag":"li","lines":"148,149"}},{"content":"9.10 C&#xf3;mo imprimir literales y secuencias de escape - P&#xe1;gina 377","children":[],"payload":{"tag":"li","lines":"149,150"}},{"content":"9.11 Formato de entrada con scanf - P&#xe1;gina 379","children":[],"payload":{"tag":"li","lines":"150,152"}}],"payload":{"tag":"li","lines":"139,152"}},{"content":"\n<p data-lines=\"152,153\">Cap&#xed;tulo 10 - Estructuras, uniones, manipulaciones de bits y enumeraciones - P&#xe1;gina 395</p>","children":[{"content":"10.1 Introducci&#xf3;n - P&#xe1;gina 396","children":[],"payload":{"tag":"li","lines":"153,154"}},{"content":"10.2 Definiciones de estructura - P&#xe1;gina 396","children":[],"payload":{"tag":"li","lines":"154,155"}},{"content":"10.3 C&#xf3;mo inicializar estructuras - P&#xe1;gina 399","children":[],"payload":{"tag":"li","lines":"155,156"}},{"content":"10.4 C&#xf3;mo tener acceso a miembros de estructuras - P&#xe1;gina 399","children":[],"payload":{"tag":"li","lines":"156,157"}},{"content":"10.5 C&#xf3;mo utilizar estructuras con funciones - P&#xe1;gina 401","children":[],"payload":{"tag":"li","lines":"157,158"}},{"content":"10.6 Typedef - P&#xe1;gina 401","children":[],"payload":{"tag":"li","lines":"158,159"}},{"content":"10.7 Ejemplo: Simulaci&#xf3;n de barajar y distribuir cartas de alto rendimiento - P&#xe1;gina 402","children":[],"payload":{"tag":"li","lines":"159,160"}},{"content":"10.8 Uniones - P&#xe1;gina 402","children":[],"payload":{"tag":"li","lines":"160,161"}},{"content":"10.9 Operadores a nivel de bits - P&#xe1;gina 406","children":[],"payload":{"tag":"li","lines":"161,162"}},{"content":"10.10 Campos de bits - P&#xe1;gina 414","children":[],"payload":{"tag":"li","lines":"162,163"}},{"content":"10.11 Constantes de enumeraci&#xf3;n - P&#xe1;gina 416","children":[],"payload":{"tag":"li","lines":"163,165"}}],"payload":{"tag":"li","lines":"152,165"}},{"content":"\n<p data-lines=\"165,166\">Cap&#xed;tulo 11 - Procesamiento de archivos - P&#xe1;gina 431</p>","children":[{"content":"11.1 Introducci&#xf3;n - P&#xe1;gina 432","children":[],"payload":{"tag":"li","lines":"166,167"}},{"content":"11.2 La jerarqu&#xed;a de datos - P&#xe1;gina 432","children":[],"payload":{"tag":"li","lines":"167,168"}},{"content":"11.3 Archivos y flujos - P&#xe1;gina 434","children":[],"payload":{"tag":"li","lines":"168,169"}},{"content":"11.4 C&#xf3;mo crear un archivo de acceso secuencial - P&#xe1;gina 435","children":[],"payload":{"tag":"li","lines":"169,170"}},{"content":"11.5 C&#xf3;mo leer datos de un archivo de acceso secuencial - P&#xe1;gina 440","children":[],"payload":{"tag":"li","lines":"170,171"}},{"content":"11.6 Archivos de acceso directo - P&#xe1;gina 445","children":[],"payload":{"tag":"li","lines":"171,172"}},{"content":"11.7 C&#xf3;mo crear un archivo de acceso directo - P&#xe1;gina 446","children":[],"payload":{"tag":"li","lines":"172,173"}},{"content":"11.8 C&#xf3;mo escribir datos directamente a un archivo de acceso directo - P&#xe1;gina 448","children":[],"payload":{"tag":"li","lines":"173,174"}},{"content":"11.9 C&#xf3;mo leer datos directamente de un archivo de acceso directo - P&#xe1;gina 450","children":[],"payload":{"tag":"li","lines":"174,175"}},{"content":"11.10 Estudio de caso: Un programa de procesamiento de transacciones - P&#xe1;gina 451","children":[],"payload":{"tag":"li","lines":"175,177"}}],"payload":{"tag":"li","lines":"165,177"}},{"content":"\n<p data-lines=\"177,178\">Cap&#xed;tulo 12 - Estructuras de datos - P&#xe1;gina 467</p>","children":[{"content":"12.1 Introducci&#xf3;n - P&#xe1;gina 468","children":[],"payload":{"tag":"li","lines":"178,179"}},{"content":"12.2 Estructuras autoreferenciadas - P&#xe1;gina 469","children":[],"payload":{"tag":"li","lines":"179,180"}},{"content":"12.3 Asignaci&#xf3;n din&#xe1;mica de memoria - P&#xe1;gina 470","children":[],"payload":{"tag":"li","lines":"180,181"}},{"content":"12.4 Listas enlazadas - P&#xe1;gina 471","children":[],"payload":{"tag":"li","lines":"181,182"}},{"content":"12.5 Pilas - P&#xe1;gina 479","children":[],"payload":{"tag":"li","lines":"182,183"}},{"content":"12.6 Colas de espera - P&#xe1;gina 484","children":[],"payload":{"tag":"li","lines":"183,184"}},{"content":"12.7 &#xc1;rboles - P&#xe1;gina 489","children":[],"payload":{"tag":"li","lines":"184,186"}}],"payload":{"tag":"li","lines":"177,186"}},{"content":"\n<p data-lines=\"186,187\">Cap&#xed;tulo 13 - El preprocesador - P&#xe1;gina 521</p>","children":[{"content":"13.1 Introducci&#xf3;n - P&#xe1;gina 522","children":[],"payload":{"tag":"li","lines":"187,188"}},{"content":"13.2 La directiva de preprocesador #include - P&#xe1;gina 522","children":[],"payload":{"tag":"li","lines":"188,189"}},{"content":"13.3 La directiva de preprocesador #define: constantes simb&#xf3;licas - P&#xe1;gina 523","children":[],"payload":{"tag":"li","lines":"189,190"}},{"content":"13.4 La directiva de preprocesador #define: macros - P&#xe1;gina 523","children":[],"payload":{"tag":"li","lines":"190,191"}},{"content":"13.5 Compilaci&#xf3;n condicional - P&#xe1;gina 525","children":[],"payload":{"tag":"li","lines":"191,192"}},{"content":"13.6 Las directivas de preprocesador #error y #pragma - P&#xe1;gina 526","children":[],"payload":{"tag":"li","lines":"192,193"}},{"content":"13.7 Los operadores # y ## - P&#xe1;gina 527","children":[],"payload":{"tag":"li","lines":"193,194"}},{"content":"13.8 N&#xfa;meros de l&#xed;nea - P&#xe1;gina 527","children":[],"payload":{"tag":"li","lines":"194,195"}},{"content":"13.9 Constantes simb&#xf3;licas predefinidas - P&#xe1;gina 528","children":[],"payload":{"tag":"li","lines":"195,196"}},{"content":"13.10 Asertos - P&#xe1;gina 528","children":[],"payload":{"tag":"li","lines":"196,198"}}],"payload":{"tag":"li","lines":"186,198"}},{"content":"\n<p data-lines=\"198,199\">Cap&#xed;tulo 14 - Temas avanzados - P&#xe1;gina 535</p>","children":[{"content":"14.1 Introducci&#xf3;n - P&#xe1;gina 536","children":[],"payload":{"tag":"li","lines":"199,200"}},{"content":"14.2 C&#xf3;mo redirigir entradas/salidas en sistemas UNIX y DOS - P&#xe1;gina 536","children":[],"payload":{"tag":"li","lines":"200,201"}},{"content":"14.3 Listas de argumentos de longitud variable - P&#xe1;gina 537","children":[],"payload":{"tag":"li","lines":"201,202"}},{"content":"14.4 C&#xf3;mo utilizar argumentos en l&#xed;nea de comandos - P&#xe1;gina 540","children":[],"payload":{"tag":"li","lines":"202,203"}},{"content":"14.5 Notas sobre la compilaci&#xf3;n de programas con varios archivos fuente - P&#xe1;gina 540","children":[],"payload":{"tag":"li","lines":"203,204"}},{"content":"14.6 Terminaci&#xf3;n de programas mediante Exit y Atexit - P&#xe1;gina 543","children":[],"payload":{"tag":"li","lines":"204,205"}},{"content":"14.7 El calificador de tipo vol&#xe1;til - P&#xe1;gina 543","children":[],"payload":{"tag":"li","lines":"205,206"}},{"content":"14.8 Sufijos para constantes de enteras y punto flotante - P&#xe1;gina 543","children":[],"payload":{"tag":"li","lines":"206,207"}},{"content":"14.9 M&#xe1;s sobre archivos - P&#xe1;gina 545","children":[],"payload":{"tag":"li","lines":"207,208"}},{"content":"14.10 Manejo de se&#xf1;ales - P&#xe1;gina 547","children":[],"payload":{"tag":"li","lines":"208,209"}},{"content":"14.11 Asignaci&#xf3;n din&#xe1;mica de memoria: funciones calloc y realloc - P&#xe1;gina 548","children":[],"payload":{"tag":"li","lines":"209,210"}},{"content":"14.12 La bifurcaci&#xf3;n incondicional: Goto - P&#xe1;gina 548","children":[],"payload":{"tag":"li","lines":"210,212"}}],"payload":{"tag":"li","lines":"198,212"}},{"content":"\n<p data-lines=\"212,213\">Cap&#xed;tulo 15 - C++ como un &quot;C mejorado&quot; - P&#xe1;gina 559</p>","children":[{"content":"15.1 Introducci&#xf3;n - P&#xe1;gina 560","children":[],"payload":{"tag":"li","lines":"213,214"}},{"content":"15.2 Comentarios de una sola l&#xed;nea de C++ - P&#xe1;gina 561","children":[],"payload":{"tag":"li","lines":"214,215"}},{"content":"15.3 Flujo de entrada/salida de C++ - P&#xe1;gina 562","children":[],"payload":{"tag":"li","lines":"215,216"}},{"content":"15.4 Declaraciones en C++ - P&#xe1;gina 563","children":[],"payload":{"tag":"li","lines":"216,217"}},{"content":"15.5 C&#xf3;mo crear nuevos tipos de datos en C++ - P&#xe1;gina 564","children":[],"payload":{"tag":"li","lines":"217,218"}},{"content":"15.6 Prototipos de funciones y verificaci&#xf3;n de tipo - P&#xe1;gina 565","children":[],"payload":{"tag":"li","lines":"218,219"}},{"content":"15.7 Funciones en l&#xed;nea - P&#xe1;gina 566","children":[],"payload":{"tag":"li","lines":"219,220"}},{"content":"15.8 Par&#xe1;metros de referencia - P&#xe1;gina 569","children":[],"payload":{"tag":"li","lines":"220,221"}},{"content":"15.9 El calificador Const - P&#xe1;gina 574","children":[],"payload":{"tag":"li","lines":"221,222"}},{"content":"15.10 Asignaci&#xf3;n din&#xe1;mica de memoria mediante new y delete - P&#xe1;gina 576","children":[],"payload":{"tag":"li","lines":"222,223"}},{"content":"15.11 Argumentos por omisi&#xf3;n - P&#xe1;gina 578","children":[],"payload":{"tag":"li","lines":"223,224"}},{"content":"15.12 Operador de resoluci&#xf3;n de alcance unario - P&#xe1;gina 578","children":[],"payload":{"tag":"li","lines":"224,225"}},{"content":"15.13 Homonimia de funciones - P&#xe1;gina 579","children":[],"payload":{"tag":"li","lines":"225,226"}},{"content":"15.14 Especificaciones de enlace - P&#xe1;gina 582","children":[],"payload":{"tag":"li","lines":"226,227"}},{"content":"15.15 Plantillas de funci&#xf3;n - P&#xe1;gina 583","children":[],"payload":{"tag":"li","lines":"227,229"}}],"payload":{"tag":"li","lines":"212,229"}},{"content":"\n<p data-lines=\"229,230\">Cap&#xed;tulo 16 - Clases y abstracci&#xf3;n de datos - P&#xe1;gina 593**</p>","children":[{"content":"16.1 Introducci&#xf3;n - P&#xe1;gina 594","children":[],"payload":{"tag":"li","lines":"230,231"}},{"content":"16.2 Definiciones de estructuras - P&#xe1;gina 596","children":[],"payload":{"tag":"li","lines":"231,232"}},{"content":"16.3 C&#xf3;mo tener acceso a miembros de estructuras - P&#xe1;gina 597","children":[],"payload":{"tag":"li","lines":"232,233"}},{"content":"16.4 C&#xf3;mo poner en pr&#xe1;ctica mediante un struct un tipo Time definido por el usuario - P&#xe1;gina 597","children":[],"payload":{"tag":"li","lines":"233,234"}},{"content":"16.5 C&#xf3;mo implantar un tipo de dato abstracto Time con una clase - P&#xe1;gina 599","children":[],"payload":{"tag":"li","lines":"234,235"}},{"content":"16.6 Alcance de clase y acceso a miembros de clase - P&#xe1;gina 605","children":[],"payload":{"tag":"li","lines":"235,236"}},{"content":"16.7 C&#xf3;mo separar el interfaz de una puesta en pr&#xe1;ctica - P&#xe1;gina 606","children":[],"payload":{"tag":"li","lines":"236,237"}},{"content":"16.8 C&#xf3;mo controlar el acceso a miembros - P&#xe1;gina 608","children":[],"payload":{"tag":"li","lines":"237,238"}},{"content":"16.9 Funciones de acceso y funciones de utiler&#xed;a - P&#xe1;gina 613","children":[],"payload":{"tag":"li","lines":"238,239"}},{"content":"16.10 C&#xf3;mo inicializar objetos de clase: constructores - P&#xe1;gina 614","children":[],"payload":{"tag":"li","lines":"239,240"}},{"content":"16.11 C&#xf3;mo utilizar argumentos por omisi&#xf3;n con los constructores - P&#xe1;gina 616","children":[],"payload":{"tag":"li","lines":"240,241"}},{"content":"16.12 C&#xf3;mo utilizar destructores - P&#xe1;gina 617","children":[],"payload":{"tag":"li","lines":"241,242"}},{"content":"16.13 Cu&#xe1;ndo son llamados los destructores y los constructores - P&#xe1;gina 619","children":[],"payload":{"tag":"li","lines":"242,243"}},{"content":"16.14 C&#xf3;mo utilizar miembros de datos y funciones miembro - P&#xe1;gina 621","children":[],"payload":{"tag":"li","lines":"243,244"}},{"content":"16.15 Una trampa sutil: c&#xf3;mo regresar una referencia a un miembro de datos privado - P&#xe1;gina 626","children":[],"payload":{"tag":"li","lines":"244,245"}},{"content":"16.16 Asignaci&#xf3;n por omisi&#xf3;n en copia a nivel de miembro - P&#xe1;gina 629","children":[],"payload":{"tag":"li","lines":"245,246"}},{"content":"16.17 Reutilizaci&#xf3;n del software - P&#xe1;gina 631","children":[],"payload":{"tag":"li","lines":"246,248"}}],"payload":{"tag":"li","lines":"229,248"}},{"content":"\n<p data-lines=\"248,249\">Cap&#xed;tulo 17 - Clases: Parte II - P&#xe1;gina 641</p>","children":[{"content":"17.1 Introducci&#xf3;n - P&#xe1;gina 642","children":[],"payload":{"tag":"li","lines":"249,250"}},{"content":"17.2 Objetos constantes y funciones de miembro const - P&#xe1;gina 642","children":[],"payload":{"tag":"li","lines":"250,251"}},{"content":"17.3 Composici&#xf3;n: clases como miembros de otras clases - P&#xe1;gina 648","children":[],"payload":{"tag":"li","lines":"251,252"}},{"content":"17.4 Funciones amigo y clases amigo - P&#xe1;gina 650","children":[],"payload":{"tag":"li","lines":"252,253"}},{"content":"17.5 C&#xf3;mo utilizar el apuntador this - P&#xe1;gina 655","children":[],"payload":{"tag":"li","lines":"253,254"}},{"content":"17.6 Asignaci&#xf3;n din&#xe1;mica de memoria mediante los operadores new y delete - P&#xe1;gina 660","children":[],"payload":{"tag":"li","lines":"254,255"}},{"content":"17.7 Miembros de clase est&#xe1;ticos - P&#xe1;gina 661","children":[],"payload":{"tag":"li","lines":"255,256"}},{"content":"17.8 Abstracci&#xf3;n de datos y ocultamiento de informaci&#xf3;n - P&#xe1;gina 665","children":[],"payload":{"tag":"li","lines":"256,257"}},{"content":"17.9 Clases contenedor e iteradores - P&#xe1;gina 668","children":[],"payload":{"tag":"li","lines":"257,258"}},{"content":"17.10 Clases plantilla - P&#xe1;gina 668","children":[],"payload":{"tag":"li","lines":"258,260"}}],"payload":{"tag":"li","lines":"248,260"}},{"content":"\n<p data-lines=\"260,261\">Cap&#xed;tulo 18 - Homonimia de operadores - P&#xe1;gina 679</p>","children":[{"content":"18.1 Introducci&#xf3;n - P&#xe1;gina 680","children":[],"payload":{"tag":"li","lines":"261,262"}},{"content":"18.2 Fundamentos de la homonimia de operadores - P&#xe1;gina 681","children":[],"payload":{"tag":"li","lines":"262,263"}},{"content":"18.3 Restricciones sobre la homonimia de operadores - P&#xe1;gina 682","children":[],"payload":{"tag":"li","lines":"263,264"}},{"content":"18.4 Funciones operador como miembros de clase en comparaci&#xf3;n con funciones amigo - P&#xe1;gina 684","children":[],"payload":{"tag":"li","lines":"264,265"}},{"content":"18.5 C&#xf3;mo hacer la homonima de operadores de inserci&#xf3;n de flujo y de extracci&#xf3;n de flujo - P&#xe1;gina 685","children":[],"payload":{"tag":"li","lines":"265,266"}},{"content":"18.6 Homonimia de operadores unarios - P&#xe1;gina 687","children":[],"payload":{"tag":"li","lines":"266,267"}},{"content":"18.7 Homonimia de operadores binarios - P&#xe1;gina 688","children":[],"payload":{"tag":"li","lines":"267,268"}},{"content":"18.8 Estudio de caso: una clase de Array - P&#xe1;gina 689","children":[],"payload":{"tag":"li","lines":"268,269"}},{"content":"18.9 Conversi&#xf3;n entre tipos - P&#xe1;gina 698","children":[],"payload":{"tag":"li","lines":"269,270"}},{"content":"18.10 Estudio de caso: una clase de String - P&#xe1;gina 700","children":[],"payload":{"tag":"li","lines":"270,271"}},{"content":"18.11 Homonimia de ++ y -- - P&#xe1;gina 709","children":[],"payload":{"tag":"li","lines":"271,272"}},{"content":"18.12 Estudio de caso: una clase de Date - P&#xe1;gina 712","children":[],"payload":{"tag":"li","lines":"272,274"}}],"payload":{"tag":"li","lines":"260,274"}},{"content":"\n<p data-lines=\"274,275\">Cap&#xed;tulo 19 - Herencia - P&#xe1;gina 729</p>","children":[{"content":"19.1 Introducci&#xf3;n - P&#xe1;gina 730","children":[],"payload":{"tag":"li","lines":"275,276"}},{"content":"19.2 Clases base y clases derivadas - P&#xe1;gina 732","children":[],"payload":{"tag":"li","lines":"276,277"}},{"content":"19.3 Miembros protegidos - P&#xe1;gina 734","children":[],"payload":{"tag":"li","lines":"277,278"}},{"content":"19.4 C&#xf3;mo hacer la conversi&#xf3;n expl&#xed;cita (cast) de apuntadores de clase base a apuntadores de clase derivada - P&#xe1;gina 734","children":[],"payload":{"tag":"li","lines":"278,279"}},{"content":"19.5 C&#xf3;mo utilizar funciones miembro - P&#xe1;gina 738","children":[],"payload":{"tag":"li","lines":"279,280"}},{"content":"19.6 C&#xf3;mo redefinir los miembros de clase base en una clase derivada - P&#xe1;gina 739","children":[],"payload":{"tag":"li","lines":"280,281"}},{"content":"19.7 Clases base p&#xfa;blicas, protegidas y privadas - P&#xe1;gina 743","children":[],"payload":{"tag":"li","lines":"281,282"}},{"content":"19.8 Clases base directas y clases base indirectas - P&#xe1;gina 743","children":[],"payload":{"tag":"li","lines":"282,283"}},{"content":"19.9 C&#xf3;mo utilizar constructores y destructores en clases derivadas - P&#xe1;gina 743","children":[],"payload":{"tag":"li","lines":"283,284"}},{"content":"19.10 Conversi&#xf3;n impl&#xed;cita de objeto de clase derivada a objeto de clase base - P&#xe1;gina 745","children":[],"payload":{"tag":"li","lines":"284,285"}},{"content":"19.11 Ingenier&#xed;a de software con herencia - P&#xe1;gina 748","children":[],"payload":{"tag":"li","lines":"285,286"}},{"content":"19.12 Composici&#xf3;n en comparaci&#xf3;n con herencia - P&#xe1;gina 749","children":[],"payload":{"tag":"li","lines":"286,287"}},{"content":"19.13 Relaciones &quot;utiliza un&quot; y &quot;conoce un&quot; - P&#xe1;gina 750","children":[],"payload":{"tag":"li","lines":"287,288"}},{"content":"19.14 Estudio de caso: Point, Circle, cylinder - P&#xe1;gina 750","children":[],"payload":{"tag":"li","lines":"288,289"}},{"content":"19.15 Herencia m&#xfa;ltiple - P&#xe1;gina 755","children":[],"payload":{"tag":"li","lines":"289,291"}}],"payload":{"tag":"li","lines":"274,291"}},{"content":"\n<p data-lines=\"291,292\">Cap&#xed;tulo 20 - Funciones virtuales y polimorfismo - P&#xe1;gina 769</p>","children":[{"content":"20.1 Introducci&#xf3;n - P&#xe1;gina 770","children":[],"payload":{"tag":"li","lines":"292,293"}},{"content":"20.2 Campos de tipo y enunciados switch - P&#xe1;gina 770","children":[],"payload":{"tag":"li","lines":"293,294"}},{"content":"20.3 Funciones virtuales - P&#xe1;gina 771","children":[],"payload":{"tag":"li","lines":"294,295"}},{"content":"20.4 Clases base abstractas y clases concretas - P&#xe1;gina 772","children":[],"payload":{"tag":"li","lines":"295,296"}},{"content":"20.5 Polimorfismo - P&#xe1;gina 773","children":[],"payload":{"tag":"li","lines":"296,297"}},{"content":"20.6 Estudio de caso: un sistema de n&#xf3;mina utilizando polimorfismo - P&#xe1;gina 774","children":[],"payload":{"tag":"li","lines":"297,298"}},{"content":"20.7 Clases nuevas y ligadura din&#xe1;mica - P&#xe1;gina 781","children":[],"payload":{"tag":"li","lines":"298,299"}},{"content":"20.8 Destructores virtuales - P&#xe1;gina 785","children":[],"payload":{"tag":"li","lines":"299,300"}},{"content":"20.9 Estudio de caso: c&#xf3;mo heredar interfaz, y puesta en pr&#xe1;ctica - P&#xe1;gina 785","children":[],"payload":{"tag":"li","lines":"300,302"}}],"payload":{"tag":"li","lines":"291,302"}},{"content":"\n<p data-lines=\"302,303\">Cap&#xed;tulo 21 - Flujo de entrada/salida de C++ - P&#xe1;gina 797</p>","children":[{"content":"21.1 Introducci&#xf3;n - P&#xe1;gina 799","children":[],"payload":{"tag":"li","lines":"303,304"}},{"content":"21.2 Flujos - P&#xe1;gina 799","children":[],"payload":{"tag":"li","lines":"304,305"}},{"content":"21.3 Salida de flujo - P&#xe1;gina 802","children":[],"payload":{"tag":"li","lines":"305,306"}},{"content":"21.4 Entrada de flujo - P&#xe1;gina 806","children":[],"payload":{"tag":"li","lines":"306,307"}},{"content":"21.5 Entrada/Salida sin formato mediante read, gcount y write - P&#xe1;gina 812","children":[],"payload":{"tag":"li","lines":"307,308"}},{"content":"21.6 Manipuladores de flujo - P&#xe1;gina 812","children":[],"payload":{"tag":"li","lines":"308,309"}},{"content":"21.7 Estados de formato de flujo - P&#xe1;gina 816","children":[],"payload":{"tag":"li","lines":"309,310"}},{"content":"21.8 Estados de errores de flujo - P&#xe1;gina 825","children":[],"payload":{"tag":"li","lines":"310,311"}},{"content":"21.9 Entradas/salidas de tipos definidos por usuario - P&#xe1;gina 827","children":[],"payload":{"tag":"li","lines":"311,312"}},{"content":"21.10 C&#xf3;mo ligar un flujo de salida con un flujo de entrada - P&#xe1;gina 829","children":[],"payload":{"tag":"li","lines":"312,314"}}],"payload":{"tag":"li","lines":"302,314"}},{"content":"\n<p data-lines=\"314,315\">Ap&#xe9;ndice E - Sistemas num&#xe9;ricos - P&#xe1;gina 893</p>","children":[{"content":"E.1 Introducci&#xf3;n - P&#xe1;gina 894","children":[],"payload":{"tag":"li","lines":"315,316"}},{"content":"E.2 C&#xf3;mo abreviar n&#xfa;meros binarios como octales y hexadecimales - P&#xe1;gina 897","children":[],"payload":{"tag":"li","lines":"316,317"}},{"content":"E.3 C&#xf3;mo convertir n&#xfa;meros octales y hexadecimales a binarios - P&#xe1;gina 898","children":[],"payload":{"tag":"li","lines":"317,318"}},{"content":"E.4 C&#xf3;mo convertir de binario, octal y hexadecimal a decimal - P&#xe1;gina 898","children":[],"payload":{"tag":"li","lines":"318,319"}},{"content":"E.5 C&#xf3;mo convertir de decimal a binario, octal o hexadecimal - P&#xe1;gina 899","children":[],"payload":{"tag":"li","lines":"319,320"}},{"content":"E.6 N&#xfa;meros binarios negativos: notaci&#xf3;n complementaria a dos - P&#xe1;gina 901","children":[],"payload":{"tag":"li","lines":"320,326"}}],"payload":{"tag":"li","lines":"314,326"}}],"payload":{"tag":"li","lines":"33,326"}}],"payload":{"tag":"li","lines":"32,326"}}],"payload":{"tag":"h3","lines":"15,16"}}],"payload":{"tag":"h2","lines":"13,14"}},{"content":"2do A&#xf1;o","children":[],"payload":{"tag":"h2","lines":"328,329"}},{"content":"3er A&#xf1;o","children":[],"payload":{"tag":"h2","lines":"332,333"}},{"content":"4to A&#xf1;o","children":[],"payload":{"tag":"h2","lines":"337,338"}},{"content":"5to A&#xf1;o","children":[],"payload":{"tag":"h2","lines":"341,342"}}],"payload":{"tag":"h1","lines":"8,9"}},{"colorFreezeLevel":7,"maxWidth":400,"initialExpandLevel":6})</script>
</body>
</html>
